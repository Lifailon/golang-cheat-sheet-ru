<h1 align="center">
    Go Cheat Sheet Ru
</h1>



<p align="center">
    Вольный и расширенный перевод оригинального репозитория <a href="https://github.com/a8m/golang-cheat-sheet">Go Cheat Sheet</a> на русский язык.
</p>

---

<h2 align="left">
    Оглавление:
</h2>

- [Другие ресурсы](#другие-ресурсы)
- [Участники](#участники)
- [Источники](#источники)
- [Описание языка](#описание-языка)
- [Базовый синтаксис](#базовый-синтаксис)
  - [Hello World](#hello-world)
  - [Операторы](#операторы)
    - [Арифметика](#арифметика)
    - [Сравнение](#сравнение)
    - [Логика](#логика)
    - [Другие](#другие)
  - [Декларации](#декларации)
  - [Функции](#функции)
    - [Замыкания](#замыкания)
    - [Вариативные функции](#вариативные-функции)
  - [Типы данных](#типы-данных)
  - [Преобразование типов](#преобразование-типов)
  - [Структуры управления](#структуры-управления)
    - [Условия if](#условия-if)
    - [Условия switch](#условия-switch)
    - [Циклы](#циклы)
  - [Типы последовательностей](#типы-последовательностей)
    - [Статические срезы](#статические-срезы)
    - [Динамические срезы](#динамические-срезы)
    - [Операции с срезами](#операции-с-срезами)
  - [Карты](#карты)

---

# Другие ресурсы

Подборка полезных и бесплатных ресурсов для изучения [Go](https://go.dev/learn) на русском языке:

- [Эффективный Go](https://github.com/Konstantin8105/Effective_Go_RU) - перевод официальной документации [Effective Go](https://go.dev/doc/effective_go) (не завершен и устарел).
- [Эффективный Go](https://github.com/0x0FACED/effective-go-ru) - перевод от сентября 2024 года.
- [Go в примерах](https://github.com/region23/gobyexample.ru) - исходный код для сборки статического сайта [Go в примерах](https://gobyexample.ru) (форк [gobyexample](https://github.com/mmcgrana/gobyexample)).
- [Введение в программирование на Go](https://github.com/maxpoletaev/golang-book) ([веб-версия](http://golang-book.ru)) - перевод книги [An Introduction to Programming in Go](https://www.golang-book.com).
- [Маленькая книга о Go](https://github.com/sefus/the-little-go-book/blob/master/ru/go.md) - перевод [The Little Go Book](https://github.com/karlseguin/the-little-go-book).
- [Паттерны параллельного программирования Go](https://github.com/Konstantin8105/Go-pipelines).
- [Курс по изучению Golang для начинающих](https://golangify.com/go/kurs-izucheniya-golang-dlya-nachinayuschih).
- [Обучение программированию на языке Go](https://code-basics.com/ru/languages/go) в тренажере (онлайн компилятор).
- [Руководство по языку Go](https://metanit.com/go/tutorial) от *Metanit*.
- [Шпаргалка по Go](https://opensource.archium.org/index.php?title=Langauge_RU) в переводе с Немецкого языка.
- [Гайды Uber по написанию кода на Go](https://github.com/sau00/uber-go-guide-ru) - русский перевод [оригинального репозитория](https://github.com/uber-go/guide).
- [GUI на Golang на GTK+ 3](https://github.com/jhekasoft/articles/blob/master/01_golang_gtk3/main.md).

Бесплатные курсы от *Stepik* с получением сертификата:

- [Go - первое знакомство](https://stepik.org/course/100208/promo) - 42 урока, 110 тестов, 45 задач (20к учащихся, рейтинг: 4.9).
- [PRO Go. Основы программирования](https://stepik.org/course/158385/promo) - 38 урока, 121 тестов, 191 задач (13к учащихся, рейтинг: 4.8).
- [Программирование на Golang](https://stepik.org/course/54403/promo) - 35 урока, 64 тестов, 94 задач (65к учащихся, рейтинг: 4.7).

Другие бесплатные курсы:

- [Разработка веб-сервисов на Golang](https://github.com/tyz910/golang-webservices?tab=readme-ov-file) - курс по Go от *Mail Ru* на платформе Coursera.
- [Основы Go](https://start.practicum.yandex/go-basics) - курс от *Яндекс Практикум* (2 модуля на 30 часов).
- [Основы Go](https://ru.hexlet.io/courses/go-basics) - курс от *Хек Слет* (34 урока, 97 тестов и 37 упражнений в тренажере).

# Участники

Если вы нашли ошибку или хотите расширить список шпаргалок, а также знаете другие источники для изучения, сообщите о них, внеся изменения через [Pull Requests](https://github.com/Lifailon/golang-cheat-sheet-ru/pulls).

# Источники

Большинство примеров кода взяты из [официального тура по Go](http://tour.golang.org), который является прекрасным введением для знакомства с языком.

Вы также можете использовать [онлайн компилятор](https://go.dev/play) на официальном сайте для запуска и проверки блоков кода.

# Описание языка

* **Императивный язык**, где описывается последовательность шагов (инструкций), которые необходимо выполнить для достижения результата. В отличии от декларативных языков, где описывается результат, который нужно получить, оставляя процесс выполнения скрытым (например, как в `SQL` или `HTML`).
* **Используется статическая типизация** для проверка типов переменных во время компиляции. Это когда тип переменной не может быть изменен после его присвоения (например, как в `TypeScript` в отличии от `JavaScript`).
* Синтаксис похож на `C` (но меньше скобок и нет точек с запятой в конце каждой строки), а структура — на `Oberon-2`.
* **Компилируется в машинный код без использования промежуточных слоев** (`Runtime`, например, как `JVM` в `Java` или `.NET` в `C#`), который должен быть установлен на машине для работы программы.
* **Нет классов**, но есть структуры с методами.
* **Не предоставляет подклассов, основанного на типах**, но имеет возможность заимствовать части реализации, встраивая типы в структуру или интерфейс ([embedding](https://go.dev/doc/effective_go#embedding)).
* **Функции могут возвращать несколько значений** и их можно присваивать переменным, так как они рассматриваются как объекты.
* Функции можно передавать в другие функции в качестве аргументов, а также функции могут возвращать другие функции как результат.
* **Имеет замыкания** (`closures`), которые позволяют функциям хранит и использовать переменные из внешней области видимости, даже если она выполняется в другом контексте (например, за пределами этой области).
* **Невозможно напрямую изменять значение указателя с помощью арифметических операций** (например, `ptr++`). Это нужно, что бы исключить возможные ошибки, такие как выход за пределы памяти или доступ к неправильным участкам памяти.
* **Встроенные примитивы параллелизма**: горутины и каналы.
* **Поддерживаются динамические и статические срезы** (`slices`, аналог списков или массивов в других языках, где элементы хранятся в порядке их добавления и индексируются числами), а также **карты** (`maps`, аналог словарей или хэш-таблиц, где содержится уникальный ключ и его значение).

# Базовый синтаксис

## Hello World

Файл `hello.go`:

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello Go")
}
```

Запуск:

`go run hello.go`

Выведет на экран `Hello Go`

## Операторы

### Арифметика

| Оператор | Описание                       |
|  -       |  -                             |
| `+`      | сложение                       |
| `-`      | вычитание                      |
| `*`      | умножение                      |
| `/`      | деление *                      |
| `%`      | остаток                        |
| `&`      | побитовое "и"                  |
| `\|`     | побитовое "или"                |
| `^`      | побитовое "исключающее или" ** |
| `&^`     | очистить бит ("и нет") **      |
| `<<`     | сдвиг влево ****               |
| `>>`     | сдвиг вправо                   |

\* Если оба операнда имеют целый тип (`int`, `int8`, `int32`, `int64`), результат также будет целым числом, при этом остаток отбрасывается. Если хотя бы один из операндов имеет тип с плавающей точкой (`float32`, `float64`), результат будет дробным числом.
\** Возвращает `0`, если биты двух операндов равны, или `1`, если биты двух операндов различны.
\*** Возвращает `0`, если соответствующий бит второго операнда равен `1`, или бит первого операнда (`0` или `1`), если соответствующий бит второго операнда равен `0`.
\**** Сдвигает все биты числа влево на указанное количество позиций (аналог умножения числа на `2` в степени количества сдвигов), а новые биты справа заполняются нулями.

### Сравнение

| Оператор  | Описание                      |
| -         | -                             |
| `==`      | равно                         |
| `!=`      | не равно                      |
| `<`       | меньше                        |
| `<=`      | меньше или равно              |
| `>`       | больше                        |
| `>=`      | больше или равно              |

### Логика

| Оператор  | Описание                      |
| -         | -                             |
| `&&`      | логическое "и"                |
| `\|\|`    | логическое "или"              |
| `!`       | логическое отрецание          |

### Другие

| Оператор  | Описание                      |
| -         | -                             |
| `&`       | адрес / создать указатель     |
| `*`       | разыменовать указатель        |
| `<-`      | оператор отправки / получения |

## Декларации

Тип указывается после идентификатора (названия переменной):

```go
var foo int // объявление без инициализации значения
var foo int = 42 // объявление с инициализацией
var foo, bar int = 42, 1302 // объявить и инициализировать несколько переменных одновременно
var foo = 42 // тип пропущен, будет выведен
foo := 42 // сокращение при объявление переменной (ключевое слово var опущено, тип данных определяется автоматически)
const constant = "Это константа, которая используется для хранения неизменяемых данных"

// iota можно использовать для увеличения числа, начиная с 0
const (
    _ = iota
    a
    b
    c = 1 << iota
    d
)
    fmt.Println(a, b) // 1 2 (0 - пропускается)
    fmt.Println(c, d) // 8 16 (2^3, 2^4)
```

## Функции

```go
// Простая функция
func functionName() {}

// Функция с параметрами (тип идет после идентификаторов)
func functionName(param1 string, param2 int) {}

// Несколько параметров одного типа
func functionName(param1, param2 int) {}

// Объявление типа для возвращаемого значения (идет после скобок параметров или во вторых скобках, если значений несколько)
func functionName() int {
    return 42
}

// Может возвращать несколько значений одновременно
func returnMulti() (int, string) {
    return 42, "foobar"
}
var x, str = returnMulti()

// Возвращаем несколько именованных результатов
func returnMulti2() (n int, s string) {
    n = 42
    s = "foobar"
    // Будут возвращены все значения объявленных переменных "n" и "s"
    return
}
var x, str = returnMulti2()

func main() {
    // Присвоить функцию переменной
    add := func(a, b int) int {
        return a + b
    }
    // Используйте имя переменной для вызова функции
    fmt.Println(add(3, 4))
}
```

### Замыкания

```go
// Дочерние функции могут получить доступ к переменным, объявленным в родительской функции
func scope() func() int{
    outer_var := 2
    foo := func() int { return outer_var}
    return foo
}

func another_scope() func() int{
    // Не скомпилируется, потому что "outer_var" и "foo" не определены в данной области видимости
    outer_var = 444
    return foo
}

func outer() (func() int, int) {
    outer_var := 2
    inner := func() int {
        outer_var += 99 // переменная изменена из внешней области
        return outer_var
    }
    inner()
    return inner, outer_var // вернуть результат внутренней функции и переменной с результатом 101
}
```

### Вариативные функции

Вариативная функция работает и вызывается как любая другая функция, за исключением того, что в нее возможно передать произвольное количество аргументов, используя `...` перед типом данных указанного параметра.

```go
func main() {
	fmt.Println(adder(1, 2, 3)) // 6
	fmt.Println(adder(9, 9))    // 18

	nums := []int{10, 20, 30}
	fmt.Println(adder(nums...)) // 60
}

func adder(args ...int) int {
	total := 0
	for _, v := range args { // перебирает все переданные аргументы в цикле
		total += v
	}
	return total
}
```

## Типы данных

```go
bool // логический тип (принимает true или false)

string // строка (текст)

int  int8  int16  int32  int64 // целое число
uint uint8 uint16 uint32 uint64 uintptr // беззнаковый целочисленный тип размером

byte // псевдоним для uint8

rune // псевдоним для int32 ~= символ (кодовая точка Unicode)

float32 float64 // число с плавающей точкой одинарной и двойной точности

complex64 complex128 // комплексное число (1 + 2i или 3.14 + 4.2i), имеющие реальную и мнимую часть

interfae{} // универсальный тип, который может позволяет работать с переменными неизвестного или изменяющегося типа
```

Все предварительно объявленные идентификаторы Go определены в пакете [builtin](https://golang.org/pkg/builtin/).

## Преобразование типов

```go
var i int = 42
var f float64 = float64(i)  // преобразуем тип данных int в float64
var u uint = uint(f)        // преобразуем тип данных float64 в unit

// Альтернативный синтаксис
i := 42
f := float64(i)
u := uint(f)
```

## Структуры управления

### Условия if

```go
func main() {
	// Базовый
	if x > 10 {
		return x
	} else if x == 10 {
		return 10
	} else {
		return -x
	}

	// Возможно поставить одно утверждение перед условием
	if a := b + c; a < 42 {
		return a
	} else {
		return a - 42
	}

	// Утверждение (проверка) типа внутри условия
	var val interface{} = "foo"
    // Проверяется, содержит ли переменная val значение типа string
	if str, ok := val.(string); ok {
        // Если тип не совпадает, значение не вернется.
        // При этом panic не вызывается, т.к. используется безопасное утверждение типа (ok)
		fmt.Println(str)
	}
}
```

### Условия switch

После выполнения условия при использование переключателей, прерывания обрабатываются автоматически.

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    var operatingSystem string = runtime.GOOS
    // Используем оператор (ключевое слово) switch
    switch operatingSystem {
    case "darwin":
        fmt.Println("Используется macOS")
    case "linux":
        fmt.Println("Используется Linux")
    // Условие по умолчанию (аналог else в if)
    default:
        fmt.Println("Используется Windows, OpenBSD, FreeBSD или другая")
    }
}

// Как в случае с "for" и "if", возможно иметь оператор присваивания перед значением switch
switch os := runtime.GOOS; os {
    case "darwin": ...
}

// Возможно использовать сравнения
number := 42
switch {
    case number < 42:
  		fmt.Println("Переданное значение:", number, "меньше 42 в условие")
    case number == 42:
		fmt.Println("Переданное значение:", number, "равно 42 в условие")
    case number > 42:
		fmt.Println("Переданное значение:", number, "больше 42 в условие")
}

// Все случаи могут быть представлены в виде списков, разделенных запятыми
var char byte = '?'
switch char {
    case ' ', '?', '&', '=', '#', '+', '%':
  		fmt.Println("Переданное значение присутствует в списке")
}
```

### Циклы

В Go используются только универсальные циклы `for`, другие операторы (например, `while` или `until`) отсутствуют.

```go
// Используется 9 интераций с 1 по 9 (до 10)
for i := 1; i < 10; i++ {
}
// Цикл (loop) - while
for ; i < 10;  {
}
// Если есть только условие, точки с запятой опускаются
for i < 10  {
}
// Если опустить условие, равноценно использованию while (true)
for {
}
    
// Использование пропуска и прерывания в цикле
// Метка here (произвольное имя) позволяет указать целевой цикл, на который будут ссылаться операторы continue и break
here:
    // Используем 2 интерации в внешнем цикле (от 0 до 1)
    for i := 0; i < 2; i++ {
        // Внутренний цикл: переменная j начинается с i+1 и проходит до 3
        for j := i + 1; j < 3; j++ {
            if i == 0 {
                // Пропустить интерацию внешнего цикла по названию его метки
                continue here
            }
            fmt.Println(j)
            if j == 2 {
                // Завершить внутренний цикл
                break
            }
        }
    }

// 1-я интерация: внешний цикл с значением i=0 в внутреннем цикле пропускает интерацию внешнего цикла, т.к. срабатывает условие i==0
// 2-я интерация: внешний цикл с значением i=1 в внутреннем цикле пропускает условие i==0
// Переменная j получает значение 2, которое печатается и завершает внутренний (текущий) цикл во втором условие
// Программа завершается, т.к. интерации внешнего цикла закончились

there:
    for i := 0; i < 2; i++ {
        for j := i + 1; j < 3; j++ {
            if j == 1 {
                // Пропускаем интерацию внутреннего цикла
                continue
            }
            fmt.Println(j)
            if j == 2 {
                // Завершаем выполнение внешнего цикла
                break there
            }
        }
    }
```

## Типы последовательностей

Массивы, срезы и диапазоны представляют собой структуры данных, хранящие упорядоченные наборы значений.

### Статические срезы

Статические срезы подразумеваются как массивы.

```go
var a [10]int // объявить массив int длиной 10 (длина массива является частью типа)
a[3] = 42     // присвоить значение элементу, по его порядковому номеру
i := a[3]     // прочитать элементы

// Возможные варианты объявление с инициализацией значений
var a = [2]int{1, 2}
// Массив из двух элементов: [1 2]
a := [2]int{1, 2}
// Многоточие используется компилятором для вычисления длины массива
a := [...]int{1, 2}
```

### Динамические срезы

Динамический срез объявляется аналогично статическому, но длина не указывается.

```go
var a []int                                 // объявить срез
var a = []int {1, 2, 3, 4}                  // объявить и инициализировать срез
a := []int{1, 2, 3, 4}                      // [1 2 3 4]
chars := []string{0:"a", 2:"c", 1: "b"}     // [a b c]

var b = a[lo:hi]	                        // создать срез от индекса lo до hi-1
var b = a[1:4]		                        // срез c индекса 1 по 3 (до 4)
var b = a[:3]		                        // отсутствие первого индекса подразумевает 0
var b = a[3:]		                        // отсутствие последнего индекса подразумевает len(a) (т.е. последний идекс по длинне индекса)
a =  append(a,17,3)	                        // добавление элементов к срезу a с помощью функции append
c := append(a,b...)	                        // объединение срезов a и b

a = make([]byte, 5, 5)	                    // первый аргумент длина, второй емкость
a = make([]byte, 5)	                        // емкость необязательна

x := [3]string{"Лайка", "Белка", "Стрелка"} // создаем массив
s := x[:]                                   // создать срез из массива
```

### Операции с срезами

`len(a)` возвращает длину среза/массива. Это встроенная функция, а не метод массива.

```go
// Цикл по массиву/срезу
for i, e := range a {
    // "i" — индекс, "e" — элемент
}

// Если нужен только элемент "e"
for _, e := range a {
    // Используется только элемент "e"
}

// Если нужен только индекс
for i := range a {
}
```

## Карты

```go
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

func main() {
	m := make(map[string]int) // объявить карту
	m["key"] = 42             // инициализировать карту
	fmt.Println(m["key"])     // вывести содержимое значения (value) по его уникальному названию клчюча
	delete(m, "key")          // удалить элемент из карты
	elem, ok := m["key"]      // проверка, если ключ присутствует, то получить его значение
	fmt.Println(ok, elem)

	var m2 = map[string]Vertex{
		"Bell Labs": {40.68433, -74.39967},
		"Google":    {37.42202, -122.08408},
	}

    // Перебрать содержимое карты в цикле
	for key, value := range m2 {
		fmt.Println(key)
		fmt.Println(value)
	}
}
```
