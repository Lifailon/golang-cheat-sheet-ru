![](logo.png)

<p align="center">
        <a href="https://lifailon.github.io/golang/"><img title="Web version"src="https://img.shields.io/badge/web%20version-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white"></a>
        <a href="Go-Cheat-Sheet-Ru.pdf"><img title="PDF version"src="https://img.shields.io/badge/pdf_version-DA1F26.svg?style=for-the-badge&logo=Adobe%20Acrobat%20Reader&logoColor=white"></a>
</p>

<p align="center">
    Вольный и расширенный перевод оригинального репозитория <a href="https://github.com/a8m/golang-cheat-sheet">Go Cheat Sheet</a> на русский язык.
</p>

---

<h2 align="left">
    Навигация:
</h2>

- [Другие ресурсы](#другие-ресурсы)
- [Участники](#участники)
- [Источники](#источники)
- [Описание языка](#описание-языка)
- [Базовый синтаксис](#базовый-синтаксис)
  - [Hello World](#hello-world)
  - [Операторы](#операторы)
    - [Арифметика](#арифметика)
    - [Сравнение](#сравнение)
    - [Логика](#логика)
    - [Другие](#другие)
  - [Декларации](#декларации)
  - [Функции](#функции)
    - [Замыкания](#замыкания)
    - [Вариативные функции](#вариативные-функции)
  - [Типы данных](#типы-данных)
  - [Преобразование типов](#преобразование-типов)
  - [Структуры управления](#структуры-управления)
    - [Условия if](#условия-if)
    - [Условия switch](#условия-switch)
    - [Циклы](#циклы)
  - [Типы последовательностей](#типы-последовательностей)
    - [Статические срезы](#статические-срезы)
    - [Динамические срезы](#динамические-срезы)
    - [Операции с срезами](#операции-с-срезами)
  - [Карты](#карты)
  - [Структуры](#структуры)
    - [Анонимные структуры](#анонимные-структуры)
    - [Указатели](#указатели)
  - [Интерфейсы](#интерфейсы)
  - [Встраивание](#встраивание)
  - [Обработка ошибок](#обработка-ошибок)
- [Параллелизм](#параллелизм)
  - [Горутины](#горутины)
  - [Синхронизация](#синхронизация)
  - [Небуферизованный канал](#небуферизованный-канал)
  - [Буферизованный канал](#буферизованный-канал)
  - [Оператор select](#оператор-select)
  - [Аксиомы канала](#аксиомы-канала)
- [Вывод](#вывод)
- [Переключение типа](#переключение-типа)
- [Пакеты](#пакеты)
  - [Встраивание файлов](#встраивание-файлов)
  - [HTTP сервер](#http-сервер)

---

# Другие ресурсы

Подборка полезных и бесплатных ресурсов для изучения [Go](https://go.dev/learn) на русском языке:

- [Эффективный Go](https://github.com/Konstantin8105/Effective_Go_RU) - перевод официальной документации [Effective Go](https://go.dev/doc/effective_go) (не завершен и устарел).
- [Эффективный Go](https://github.com/0x0FACED/effective-go-ru) - перевод от сентября 2024 года.
- [Go в примерах](https://github.com/region23/gobyexample.ru) - исходный код для сборки статического сайта [Go в примерах](https://gobyexample.ru) (форк [gobyexample](https://github.com/mmcgrana/gobyexample)).
- [Введение в программирование на Go](https://github.com/maxpoletaev/golang-book) ([веб-версия](http://golang-book.ru)) - перевод книги [An Introduction to Programming in Go](https://www.golang-book.com).
- [Маленькая книга о Go](https://github.com/sefus/the-little-go-book/blob/master/ru/go.md) - перевод [The Little Go Book](https://github.com/karlseguin/the-little-go-book).
- [Паттерны параллельного программирования Go](https://github.com/Konstantin8105/Go-pipelines).
- [Курс по изучению Golang для начинающих](https://golangify.com/go/kurs-izucheniya-golang-dlya-nachinayuschih).
- [Обучение программированию на языке Go](https://code-basics.com/ru/languages/go) в тренажере (онлайн компилятор).
- [Руководство по языку Go](https://metanit.com/go/tutorial) от *Metanit*.
- [Шпаргалка по Go](https://opensource.archium.org/index.php?title=Langauge_RU) в переводе с Немецкого языка.
- [Гайды Uber по написанию кода на Go](https://github.com/sau00/uber-go-guide-ru) - русский перевод [оригинального репозитория](https://github.com/uber-go/guide).
- [GUI на Golang на GTK+ 3](https://github.com/jhekasoft/articles/blob/master/01_golang_gtk3/main.md).

Бесплатные курсы от *Stepik* с получением сертификата:

- [Go - первое знакомство](https://stepik.org/course/100208/promo) - 42 урока, 110 тестов, 45 задач (20к учащихся, рейтинг: 4.9).
- [PRO Go. Основы программирования](https://stepik.org/course/158385/promo) - 38 урока, 121 тестов, 191 задач (13к учащихся, рейтинг: 4.8).
- [Программирование на Golang](https://stepik.org/course/54403/promo) - 35 урока, 64 тестов, 94 задач (65к учащихся, рейтинг: 4.7).

Другие бесплатные курсы:

- [Разработка веб-сервисов на Golang](https://github.com/tyz910/golang-webservices?tab=readme-ov-file) - курс по Go от *Mail Ru* на платформе Coursera.
- [Основы Go](https://start.practicum.yandex/go-basics) - курс от *Яндекс Практикум* (2 модуля на 30 часов).
- [Основы Go](https://ru.hexlet.io/courses/go-basics) - курс от *Хек Слет* (34 урока, 97 тестов и 37 упражнений в тренажере).

# Участники

Если вы нашли ошибку или хотите расширить список шпаргалок, а также знаете другие источники для изучения, сообщите о них, внеся изменения через [Pull Requests](https://github.com/Lifailon/golang-cheat-sheet-ru/pulls).

# Источники

Большинство примеров кода взяты из [официального тура по Go](http://tour.golang.org), который является прекрасным введением для знакомства с языком.

Вы также можете использовать [онлайн компилятор](https://go.dev/play) на официальном сайте для запуска и проверки блоков кода.

# Описание языка

* **Императивный язык**, где описывается последовательность шагов (инструкций), которые необходимо выполнить для достижения результата. В отличии от декларативных языков, где описывается результат, который нужно получить, оставляя процесс выполнения скрытым (например, как в `SQL` или `HTML`).
* **Используется статическая типизация** для проверка типов переменных во время компиляции. Это когда тип переменной не может быть изменен после его присвоения (например, как в `TypeScript` в отличии от `JavaScript`).
* Синтаксис похож на `C` (но меньше скобок и нет точек с запятой в конце каждой строки), а структура — на `Oberon-2`.
* **Компилируется в машинный код без использования промежуточных слоев** (`Runtime`, например, как `JVM` в `Java` или `.NET` в `C#`), который должен быть установлен на машине для работы программы.
* **Нет классов**, но есть структуры с методами.
* **Не предоставляет подклассов, основанного на типах**, но имеет возможность заимствовать части реализации, встраивая типы в структуру или интерфейс ([embedding](https://go.dev/doc/effective_go#embedding)).
* **Функции могут возвращать несколько значений** и их можно присваивать переменным, так как они рассматриваются как объекты.
* Функции можно передавать в другие функции в качестве аргументов, а также функции могут возвращать другие функции как результат.
* **Имеет замыкания** (`closures`), которые позволяют функциям хранит и использовать переменные из внешней области видимости, даже если она выполняется в другом контексте (например, за пределами этой области).
* **Невозможно напрямую изменять значение указателя с помощью арифметических операций** (например, `ptr++`). Это нужно, что бы исключить возможные ошибки, такие как выход за пределы памяти или доступ к неправильным участкам памяти.
* **Встроенные примитивы параллелизма**: горутины и каналы.
* **Поддерживаются динамические и статические срезы** (`slices`, аналог списков или массивов в других языках, где элементы хранятся в порядке их добавления и индексируются числами), а также **карты** (`maps`, аналог словарей или хэш-таблиц, где содержится уникальный ключ и его значение).

# Базовый синтаксис

## Hello World

Файл `hello.go`:

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello Go")
}
```

Запуск:

`go run hello.go`

Выведет на экран `Hello Go`

## Операторы

### Арифметика

| Оператор | Описание                       |
|  -       |  -                             |
| `+`      | сложение                       |
| `-`      | вычитание                      |
| `*`      | умножение                      |
| `/`      | деление *                      |
| `%`      | остаток                        |
| `&`      | побитовое `и`                  |
| `\|`     | побитовое `или`                |
| `^`      | побитовое `исключающее или` * *|
| `&^`     | очистить бит (`и нет`) * * *   |
| `<<`     | сдвиг влево * * * *            |
| `>>`     | сдвиг вправо                   |

\* Если оба операнда имеют целый тип (`int`, `int8`, `int32`, `int64`), результат также будет целым числом, при этом остаток отбрасывается. Если хотя бы один из операндов имеет тип с плавающей точкой (`float32`, `float64`), результат будет дробным числом.

\* * Возвращает `0`, если биты двух операндов равны, или `1`, если биты двух операндов различны.

\* * * Возвращает `0`, если соответствующий бит второго операнда равен `1`, или бит первого операнда (`0` или `1`), если соответствующий бит второго операнда равен `0`.

\* * * * Сдвигает все биты числа влево на указанное количество позиций (аналог умножения числа на `2` в степени количества сдвигов), а новые биты справа заполняются нулями.

### Сравнение

| Оператор  | Описание                      |
| -         | -                             |
| `==`      | равно                         |
| `!=`      | не равно                      |
| `<`       | меньше                        |
| `<=`      | меньше или равно              |
| `>`       | больше                        |
| `>=`      | больше или равно              |

### Логика

| Оператор  | Описание                      |
| -         | -                             |
| `&&`      | логическое `и`                |
| `\|\|`    | логическое `или`              |
| `!`       | логическое отрецание          |

### Другие

| Оператор  | Описание                      |
| -         | -                             |
| `&`       | адрес / создать указатель     |
| `*`       | разыменовать указатель        |
| `<-`      | оператор отправки / получения |

## Декларации

Тип указывается после идентификатора (названия переменной):

```go
var foo int                 // объявление без инициализации значения
var foo int = 42            // объявление с инициализацией
var foo, bar int = 42, 1302 // объявить и инициализировать несколько переменных одновременно
var foo = 42                // тип пропущен, будет выведен
foo := 42                   // сокращение при объявление переменной (ключевое слово var опущено, тип данных определяется автоматически)
const constant = "Это константа, которая используется для хранения неизменяемых данных"

// iota можно использовать для увеличения числа, начиная с 0
const (
    _ = iota
    a
    b
    c = 1 << iota
    d
)
    fmt.Println(a, b) // 1 2 (0 - пропускается)
    fmt.Println(c, d) // 8 16 (2^3, 2^4)
```

## Функции

```go
// Простая функция
func functionName() {}

// Функция с параметрами (тип идет после идентификаторов)
func functionName(param1 string, param2 int) {}

// Несколько параметров одного типа
func functionName(param1, param2 int) {}

// Объявление типа для возвращаемого значения (идет после скобок параметров или во вторых скобках, если значений несколько)
func functionName() int {
    return 42
}

// Может возвращать несколько значений одновременно
func returnMulti() (int, string) {
    return 42, "foobar"
}
var x, str = returnMulti()

// Возвращаем несколько именованных результатов
func returnMulti2() (n int, s string) {
    n = 42
    s = "foobar"
    // Будут возвращены все значения объявленных переменных "n" и "s"
    return
}
var x, str = returnMulti2()

func main() {
    // Присвоить функцию переменной
    add := func(a, b int) int {
        return a + b
    }
    // Используйте имя переменной для вызова функции
    fmt.Println(add(3, 4))
}
```

### Замыкания

```go
// Дочерние функции могут получить доступ к переменным, объявленным в родительской функции
func scope() func() int{
    outer_var := 2
    foo := func() int { return outer_var}
    return foo
}

func another_scope() func() int{
    // Не скомпилируется, потому что "outer_var" и "foo" не определены в данной области видимости
    outer_var = 444
    return foo
}

func outer() (func() int, int) {
    outer_var := 2
    inner := func() int {
        outer_var += 99 // переменная изменена из внешней области
        return outer_var
    }
    inner()
    return inner, outer_var // вернуть результат внутренней функции и переменной с результатом 101
}
```

### Вариативные функции

Вариативная функция работает и вызывается как любая другая функция, за исключением того, что в нее возможно передать произвольное количество аргументов, используя `...` перед типом данных указанного параметра.

```go
func main() {
    fmt.Println(adder(1, 2, 3)) // 6
    fmt.Println(adder(9, 9))    // 18

    nums := []int{10, 20, 30}
    fmt.Println(adder(nums...)) // 60
}

func adder(args ...int) int {
    total := 0
    for _, v := range args { // перебирает все переданные аргументы в цикле
    	total += v
    }
    return total
}
```

## Типы данных

```go
bool // логический тип (принимает true или false)

string // строка (текст)

int  int8  int16  int32  int64 // целое число
uint uint8 uint16 uint32 uint64 uintptr // беззнаковый целочисленный тип размером

byte // псевдоним для uint8

rune // псевдоним для int32 ~= символ (кодовая точка Unicode)

float32 float64 // число с плавающей точкой одинарной и двойной точности

complex64 complex128 // комплексное число (1 + 2i или 3.14 + 4.2i), имеющие реальную и мнимую часть

interfae{} // универсальный тип, который может позволяет работать с переменными неизвестного или изменяющегося типа
```

Все предварительно объявленные идентификаторы `Go` определены в пакете [builtin](https://golang.org/pkg/builtin).

## Преобразование типов

```go
var i int = 42
var f float64 = float64(i)  // преобразуем тип данных int в float64
var u uint = uint(f)        // преобразуем тип данных float64 в unit

// Альтернативный синтаксис
i := 42
f := float64(i)
u := uint(f)
```

## Структуры управления

### Условия if

```go
func main() {
    // Базовый
    if x > 10 {
    	return x
    } else if x == 10 {
    	return 10
    } else {
    	return -x
    }

    // Возможно поставить одно утверждение перед условием
    if a := b + c; a < 42 {
    	return a
    } else {
    	return a - 42
    }

    // Утверждение (проверка) типа внутри условия
    var val interface{} = "foo"
    // Проверяется, содержит ли переменная val значение типа string
    if str, ok := val.(string); ok {
        // Если тип не совпадает, значение не вернется.
        // При этом panic не вызывается, т.к. используется безопасное утверждение типа (ok)
    	fmt.Println(str)
    }
}
```

### Условия switch

После выполнения условия при использование переключателей, прерывания обрабатываются автоматически.

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    var operatingSystem string = runtime.GOOS
    // Используем оператор (ключевое слово) switch
    switch operatingSystem {
    case "darwin":
        fmt.Println("Используется macOS")
    case "linux":
        fmt.Println("Используется Linux")
    // Условие по умолчанию (аналог else в if)
    default:
        fmt.Println("Используется Windows, OpenBSD, FreeBSD или другая")
    }
}

// Как в случае с "for" и "if", возможно иметь оператор присваивания перед значением switch
switch os := runtime.GOOS; os {
    case "darwin": ...
}

// Возможно использовать сравнения
number := 42
switch {
    case number < 42:
        fmt.Println("Переданное значение:", number, "меньше 42 в условие")
    case number == 42:
        fmt.Println("Переданное значение:", number, "равно 42 в условие")
    case number > 42:
        fmt.Println("Переданное значение:", number, "больше 42 в условие")
}

// Все случаи могут быть представлены в виде списков, разделенных запятыми
var char byte = '?'
switch char {
    case ' ', '?', '&', '=', '#', '+', '%':
        fmt.Println("Переданное значение присутствует в списке")
}
```

### Циклы

В `Go` используются только универсальные циклы `for`, другие операторы (например, `while` или `until`) отсутствуют.

```go
// Используется 9 интераций с 1 по 9 (до 10)
for i := 1; i < 10; i++ {
}
// Цикл (loop) - while
for ; i < 10;  {
}
// Если есть только условие, точки с запятой опускаются
for i < 10  {
}
// Если опустить условие, равноценно использованию while (true)
for {
}
    
// Использование пропуска и прерывания в цикле
// Метка here (произвольное имя) позволяет указать целевой цикл, на который будут ссылаться операторы continue и break
here:
    // Используем 2 интерации в внешнем цикле (от 0 до 1)
    for i := 0; i < 2; i++ {
        // Внутренний цикл: переменная j начинается с i+1 и проходит до 3
        for j := i + 1; j < 3; j++ {
            if i == 0 {
                // Пропустить интерацию внешнего цикла по названию его метки
                continue here
            }
            fmt.Println(j)
            if j == 2 {
                // Завершить внутренний цикл
                break
            }
        }
    }

// 1-я интерация: внешний цикл с значением i=0 в внутреннем цикле пропускает интерацию внешнего цикла, т.к. срабатывает условие i==0
// 2-я интерация: внешний цикл с значением i=1 в внутреннем цикле пропускает условие i==0
// Переменная j получает значение 2, которое печатается и завершает внутренний (текущий) цикл во втором условие
// Программа завершается, т.к. интерации внешнего цикла закончились

there:
    for i := 0; i < 2; i++ {
        for j := i + 1; j < 3; j++ {
            if j == 1 {
                // Пропускаем интерацию внутреннего цикла
                continue
            }
            fmt.Println(j)
            if j == 2 {
                // Завершаем выполнение внешнего цикла
                break there
            }
        }
    }
```

## Типы последовательностей

Массивы, срезы и диапазоны представляют собой структуры данных, хранящие упорядоченные наборы значений.

### Статические срезы

Статические срезы подразумеваются как массивы.

```go
var a [10]int // объявить массив int длиной 10 (длина массива является частью типа)
a[3] = 42     // присвоить значение элементу, по его порядковому номеру
i := a[3]     // прочитать элементы

// Возможные варианты объявление с инициализацией значений
var a = [2]int{1, 2}
// Массив из двух элементов: [1 2]
a := [2]int{1, 2}
// Многоточие используется компилятором для вычисления длины массива
a := [...]int{1, 2}
```

### Динамические срезы

Динамический срез объявляется аналогично статическому, но длина не указывается.

```go
var a []int                                 // объявить срез
var a = []int {1, 2, 3, 4}                  // объявить и инициализировать срез
a := []int{1, 2, 3, 4}                      // [1 2 3 4]
chars := []string{0:"a", 2:"c", 1: "b"}     // [a b c]

var b = a[lo:hi]                            // создать срез от индекса lo до hi-1
var b = a[1:4]                              // срез c индекса 1 по 3 (до 4)
var b = a[:3]                               // отсутствие первого индекса подразумевает 0
var b = a[3:]                               // отсутствие последнего индекса подразумевает len(a) (т.е. последний идекс по длинне индекса)
a =  append(a,17,3)                         // добавление элементов к срезу a с помощью функции append
c := append(a,b...)                         // объединение срезов a и b

a = make([]byte, 5, 5)                      // первый аргумент длина, второй емкость
a = make([]byte, 5)                         // емкость необязательна

x := [3]string{"Лайка", "Белка", "Стрелка"} // создаем массив
s := x[:]                                   // создать срез из массива
```

### Операции с срезами

`len(a)` возвращает длину среза/массива. Это встроенная функция, а не метод массива.

```go
// Цикл по массиву/срезу
for i, e := range a {
    // "i" — индекс, "e" — элемент
}

// Если нужен только элемент "e"
for _, e := range a {
    // Используется только элемент "e"
}

// Если нужен только индекс
for i := range a {
}
```

## Карты

```go
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

func main() {
    m := make(map[string]int) // объявить карту
    m["key"] = 42             // инициализировать карту
    fmt.Println(m["key"])     // вывести содержимое значения (value) по его уникальному названию клчюча
    delete(m, "key")          // удалить элемент из карты
    elem, ok := m["key"]      // проверка, если ключ присутствует, то получить его значение
    fmt.Println(ok, elem)

    var m2 = map[string]Vertex{
        "Bell Labs": {40.68433, -74.39967},
        "Google":    {37.42202, -122.08408},
    }

    // Перебрать содержимое карты в цикле
    for key, value := range m2 {
        fmt.Println(key)
        fmt.Println(value)
    }
}
```

## Структуры

Вместо классов (`class`) в `Go` используются структуры (тип данных `struct`), которые могут иметь методы. Поля структуры всегда инициализируются нулевыми значениями при её объявлении.

```go
// Объявление структуры с названием Vertex с помощью ключевого слова "type"
type Vertex struct {
    X, Y float64
}

// Создание структуры
var v = Vertex{1, 2}                // инициализация данных в структуре
var v = []Vertex{{1,2},{5,2},{5,5}} // инициализация среза в структуре
var v = Vertex{X: 1, Y: 2}          // создание структуры с опредилением значений с помощью ключей
v.X = 4                             // доступ к значениям

// Объявление метода (принимающий тип), находится между ключевым словом func и именем метода
// Структура копируется при каждом вызове метода
func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// Вызов метода
v.Abs()

// Для мутирующих методов необходимо использовать указатель (см. ниже) на Struct в качестве типа
// При этом значение структуры не копируется для вызова метода
func (v *Vertex) add(n float64) {
    v.X += n
    v.Y += n
}
```

### Анонимные структуры

Безопаснее и дешевле, чем использование `map[string]interface{}`.

```go
point := struct {
	X, Y int
} {1, 2}
```

### Указатели

```go
p := Vertex{1, 2}  // "p" это структура Vertex
q := &p            // "q" указывает на структуру Vertex
r := &Vertex{1, 2} // "r" также указывает на структуру Vertex

// Объявление переменной с указателем на структуру *Vertex
var s *Vertex = new(Vertex) // функция "new" создает указатель на новый экземпляр структуры
```

## Интерфейсы

**Интерфейс** - это набор методов (требований), которые должен иметь тип, чтобы соответствовать этому интерфейсу.

```go
// Объявление интерфейса с одинм методом Awesomize(), который возвращает строку
type Awesomizer interface {
    Awesomize() string
}

// Обычная структура, которая может реализовывать методы
type Foo struct {}

// Добавление (реализация) метода Awesomize() в структуре Foo
// Тип автоматически соответствует интерфейсу, если он реализует все его методы
func (foo Foo) Awesomize() string {
    return "Awesome!"
}
```

## Встраивание

В `Go` нет подклассов, вместо этого используется встраивание интерфейса и структуры, которое добавляет методы встроенной структуры к внешней.

```go
// В структуру Server встраиваются все методы, которые есть у метода Logger из структуры log
type Server struct {
    Host string
    Port int
    *log.Logger
}

// Структура Server инициализируется с помощью указателя на log.Logger
server := &Server{"localhost", 80, log.New(...)}

// Когда вызывается server.Log(...), Go автоматически перенаправляет вызов к server.Logger.Log(...).
server.Log(...)

// Поле встроенного типа доступно через его имя, по этому переменной можно присвоить ссылку на server.Logger
var logger *log.Logger = server.Logger
```

## Обработка ошибок

Обработка исключений отсутствует. Вместо этого функции, которые могут выдать ошибку, просто объявляют дополнительное возвращаемое значение типа [error](https://golang.org/pkg/builtin/#error) (чаще всего вторым возвращаемым параметром).

Встроенный тип интерфейса `error` — это общепринятый интерфейс для представления состояния ошибки, при этом нулевое значение не представляет ошибки.

```go
type error interface {
    Error() string
}
```

Пример:

```go
package main

import (
	"errors"
	"fmt"
	"math"
)

// Определение функции sqrt должно быть вне main
func sqrt(x float64) (float64, error) {
	if x < 0 {
		return 0, errors.New("ошибка: отрицательное значение")
	}
	return math.Sqrt(x), nil
}

func main() {
	val, err := sqrt(-1)
	if err != nil {
		// Обработка ошибки
		fmt.Println(err) // отрицательное значение
		return
	}
	// Если все хорошо (переданное значение не отрицательное), вывести содержимое "val"
	fmt.Println(val)
}
```

# Параллелизм

## Горутины

**Горутины** — это легковесные потоки (управляемые `Go`, а не потоками ОС).

`go f(a, b)` запускает новую горутину, которая запускает `f` (при условии, что `f` — это функция).

```go
// Просто функция (которая позже может быть запущена в горутине)
func doStuff(s string) {
    fmt.Println(s)
}

func main() {
    // Запуск существующий функции в горутине по ее имени
    go doStuff("foobar")

    // Использование анонимной внутренней функции в горутине
    go func (x int) {
        fmt.Println(x)
    } (42) // Параметр анонимной функции
}
```

## Синхронизация

Пакет `sync` используется для ожидания завершения всех запущенных горутин.

```go
package main

import (
	"fmt"
	"sync"
)

func doStuff(s string, wg *sync.WaitGroup) {
	fmt.Println(s)
    defer wg.Done()
}

func main() {
    // Объект для отслеживания завершение групп горутин
	var wg sync.WaitGroup

	// Задаем счетчик для запуска 2-х горутин
	wg.Add(2)

	// Запуск функции в горутине
	go doStuff("foobar", &wg)

	// Запуск анонимной функции в горутине
	go func(x int, wg *sync.WaitGroup) {
		fmt.Println(x)
        // Уменьшить счётчик WaitGroup, когда горутина завершится
        defer wg.Done()
	}(42, &wg)

	// Ожидание завершения всех горутин
	wg.Wait()
}
```

## Небуферизованный канал

**Небуферизованный канал** блокирует операцию записи, пока не будет выполнено чтение, и наоборот.

```go
// Создаем небуферизованный канал типа "int"
ch := make(chan int)
// Отправляем значение 42 в канал "ch"
// Операция блокирует текущую горутину, пока другая горутина не прочитает его значение
ch <- 42
// Получаем значение из канала "ch"
// Это также блокирует выполнение, пока не будет доступно значение для чтения в канале
v := <-ch
```

## Буферизованный канал

**Буферизованный канал** позволяет отправлять и получать данные без блокировки, пока размер буфера не будет превышен, как только буфер заполняется, запись блокируется, пока другие горутины не начнут извлекать значения из канала.

**Закрытие канала** — это сигнал получателю, что больше значений не будет отправляться в канал, при этом отправленные в него данные не удаляются. Это необходимо для того, чтобы получатели знали, что можно завершить чтение. Закрытие канала происходило только в той горутине, которая отправляет данные.

```go
package main

import "fmt"

func main() {
	// Создаем буферизованный канал с размером буфера 100
	ch := make(chan int, 100)

	// Отправляем некоторое количество значений в канал
	for i := 0; i < 10; i++ {
		ch <- i
	}

	// Закрываем канал, чтобы цикл мог завершиться
	close(ch)

	// Читать из канала, пока он не будет закрыт
	for i := range ch {
		fmt.Println(i)
	}

	// Прочитать данные из канала и проверить, закрыт ли он
	v, ok := <-ch
	if !ok {
		fmt.Println("Канал закрыт, данные не доступны")
	} else {
		fmt.Println("Прочитано из канала:", v)
	}
}
```

Вывод: `0 1 2 3 4 5 6 7 8 9 Канал закрыт, данные не доступны`

## Оператор select

Оператор `select` работает как многоканальный оператор `switch`. Выбор блоков в операциях с несколькими каналами, если один из них разблокируется, выполняется соответствующие условие. Он блокируется до тех пор, пока одно из выражений `case` не будет готов к выполнению, при этом остальные игнорируются.

```go
package main

import (
	"fmt"
	"time"
)

func doStuff(channelOut, channelIn chan int) {
    select {
    case channelOut <- 42:
        fmt.Println("Отправить значение 42 в channelOut")
    case x := <-channelIn:
        fmt.Println("Прочитать из channelIn:", x)
    case <-time.After(time.Second * 1):
        fmt.Println("Задержка в одну секунду")
    }
}

func main() {
    // Создание двух каналов (один для записи, другой для чтения)
    channelOut := make(chan int)
    channelIn := make(chan int)

    // Запуск горутины для записи в канал "channelOut"
    go func() {
        time.Sleep(500 * time.Millisecond) // Пауза перед отправкой
        channelOut <- 42                   // Отправить значение 42
        fmt.Println("Значение 42 отправлено в channelOut")
    }()

    // Запуск горутины для чтения из канала "channelIn"
    go func() {
        time.Sleep(200 * time.Millisecond) // Пауза перед отправкой
        channelIn <- 99                    // Отправить значение 99
        fmt.Println("Значение 99 отправлено в channelIn")
    }()

    // Запуск функции doStuff с двумя каналами
    doStuff(channelOut, channelIn)
}
```

## Аксиомы канала

- Отправка в пустой канал блокирует навсегда и вызывает фатальную ошибку:

```go
var c chan string
c <- "Hello, World!"
```

- Чтение из нулевого канала блокируется навсегда:

```go
var c chan string
fmt.Println(<-c)
```
- Отправка в закрытый канал вызывает панику:

```go
var c = make(chan string, 1)
c <- "Hello, World!"
close(c)
c <- "Hello, Panic!"
```
- Прием из закрытого канала немедленно возвращает нулевое значение:

```go
var c = make(chan int, 2)
c <- 1
c <- 2
close(c)
for i := 0; i < 3; i++ {
    fmt.Printf("%d ", <-c)
}
// 1 2 0
```

# Вывод

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, 你好, नमस्ते, Привет, ᎣᏏᏲ") // базовый вывод
    p := struct{ X, Y int }{17, 2}
    fmt.Println("My point:", p, "x coord=", p.X)       // вывод структуры, цифр
    s := fmt.Sprintln("My point:", p, "x coord=", p.X) // вывод в переменную с типом данных string
    fmt.Println(s)

    fmt.Printf("%d hex:%x bin:%b fp:%f sci:%e", 17, 17, 17, 17.0, 17.0) // C-образный формат
    s2 := fmt.Sprintf("%d %f", 17, 17.0)                                // форматировать вывод в переменную с типом данных string
    fmt.Println(s2)

	// Многострочный строковый литерал
    hellomsg := `
        "Hello" in Chinese is 你好 ('Ni Hao')
        "Hello" in Hindi is नमस्ते ('Namaste')
    `
    fmt.Println(hellomsg)
}

```

# Переключение типа

Переключение типа похоже на обычный оператор `switch`, но в условиях указывается типы (а не на значения), которые сравниваются с типом значения, содержащегося в данном значении интерфейса.

```go
package main

import "fmt"

func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf("Число %v равно %v по типу данных\n", v, v*2)
	case string:
		fmt.Printf("Значение %q равно %v bytes\n", v, len(v))
	default:
		fmt.Printf("Тип %T неизвестен\n", v)
	}
}

func main() {
	do(21)
	do("hello")
	do(true)
}

// Число 21 равно 42 по типу данных
// Значение "hello" равно 5 bytes
// Тип bool неизвестен
```

# Пакеты

* Декларация пакета (объявление через `import`) производится в начале каждого исходного файла.
* Исполняемые файлы находятся в пакете `main`.
* Имя пакета соответствует последнему имени в пути импорта (путь импорта `math/rand` => пакет `rand`).
* Идентификатор функции в верхнем регистре является экспортируемый (доступны из других пакетов).
* Идентификатор функции в нижнем регистре является частный (недоступны из других пакетов).

## Встраивание файлов

Программы `Go` могут встраивать статические файлы с помощью пакета `embed` и директиву `go:embed path/filename`:

```go
package main

import (
    "embed"
    "fmt"
    "io"
    "log"
    "net/http"
)

//go:embed static/*
var content embed.FS

func main() {
    http.Handle("/", http.FileServer(http.FS(content)))
    go func() {
        log.Fatal(http.ListenAndServe(":8080", nil))
    }()

    // Чтение содержимого файлов из файловой системы
    entries, err := content.ReadDir("static")
    if err != nil {
        log.Fatal(err)
    }

    for _, e := range entries {
        resp, err := http.Get("http://localhost:8080/static/" + e.Name())
        if err != nil {
            log.Fatal(err)
        }
        body, err := io.ReadAll(resp.Body)
        if err != nil {
            log.Fatal(err)
        }
        if err := resp.Body.Close(); err != nil {
            log.Fatal(err)
        }
        fmt.Printf("%q: %s", e.Name(), body)
    }

    // Блокировка программы, чтобы сервер продолжал работать для доступа к статическим файлам через Web-интерфейс
    select {}
}

// Имитация реальных файлов с их содержимым для запуска Playground
-- static/a.txt --
hello a
-- static/b.txt --
hello b
```

## HTTP сервер

Реализация простого `API` сервера на базе встроенной библиотеки `net/http`:

```go
package main

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// Обработчик API
func apiHandler(w http.ResponseWriter, r *http.Request) {
	// Устанавливаем заголовок для ответа (Content-Type: application/json)
	w.Header().Set("Content-Type", "application/json")

	switch r.Method {
	case "GET":
		// Получение параметра "name" из URL
		name := r.URL.Query().Get("name")
		if name == "" {
			name = "Guest" // Значение по умолчанию, если параметр отсутствует
		}
		// Формируем JSON-ответ
		json.NewEncoder(w).Encode(map[string]string{
			"message": fmt.Sprintf("Hi %s", name),
		})

	case "POST":
		// Парсим JSON из тела запроса
		var data map[string]interface{}
		if err := json.NewDecoder(r.Body).Decode(&data); err != nil {
			http.Error(w, "invalid JSON", http.StatusBadRequest)
			return
		}

		// Формируем JSON-ответ
		json.NewEncoder(w).Encode(map[string]interface{}{
			"received": data,
			"status":   "OK",
		})

	default:
		// Обработка неподдерживаемых методов
		http.Error(w, "Метод не поддерживается", http.StatusMethodNotAllowed)
	}
}

func main() {
	// Регистрируем обработчик для пути /api
	http.HandleFunc("/api", apiHandler)

	// Запуск сервера
	fmt.Println("Сервер запущен на http://localhost:8080")
	http.ListenAndServe(":8080", nil)
}
```

Делаем запрос к API на клиенте:

```bash
curl -s "http://localhost:8080/api" | jq .message # "Hi Guest"
curl -s "http://localhost:8080/api?name=Alex" | jq .message # "Hi Alex"
curl -s -X POST -d '{"key":"value"}' -H "Content-Type: application/json" http://localhost:8080/api | jq .received.key # "value"
curl -s -X POST "http://localhost:8080/api" # invalid JSON
```
